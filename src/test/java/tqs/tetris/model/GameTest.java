package tqs.tetris.model;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import org.junit.jupiter.api.Test;

public class GameTest {

    /**
     * Test the construction of a Game object with different parameters
     * verify default constructor, setters and getters
     */
    @Test
    public void gameConstructionTest() {
        Game game = new Game();
        MockBoard mockBoard = new MockBoard(10, 20);
        game.setBoard(mockBoard);
        assertEquals(mockBoard, game.getBoard());

        MockTetrominoFactory mockFactory = new MockTetrominoFactory('I', 1);
        game.setTetrominoFactory(mockFactory);
        assertEquals(mockFactory, game.getTetrominoFactory());

        // Can be RUNNING, PAUSED, or GAME_OVER
        game.setGameState(GameState.RUNNING);
        assertEquals(GameState.RUNNING, game.getGameState());

        Game game2 = new Game(mockBoard, mockFactory, GameState.RUNNING);
        assertEquals(mockBoard, game2.getBoard());
        assertEquals(mockFactory, game2.getTetrominoFactory());
        assertEquals(GameState.RUNNING, game2.getGameState());
    }

    /**
     * Test the game state transitions: RUNNING <-> PAUSED <-> GAME_OVER
     * verify that the game initially starts in running state, and can be paused, resumed, and gameover
     */
    @Test
    public void gameStateTest() {
        MockBoard mockBoard = new MockBoard(10, 20);
        MockTetrominoFactory mockFactory = new MockTetrominoFactory('I', 1); // âœ… fixed spelling
        MockGameState mockStateRunning = new MockGameState("RUNNING");
        Game game = new Game(mockBoard, mockFactory, mockStateRunning.getValue());
        assertEquals(mockStateRunning.getValue(), game.getGameState());

        MockGameState mockStatePaused = new MockGameState("PAUSED");
        game.pause();
        assertEquals(mockStatePaused.getValue(), game.getGameState());

        game.resume();
        assertEquals(mockStateRunning.getValue(), game.getGameState());

        MockGameState mockStateGameOver = new MockGameState("GAME_OVER");
        game.gameOver();
        assertEquals(mockStateGameOver.getValue(), game.getGameState());
    }

    /**
     * Test spawning a new piece at the top center of the board
     * verify that the initial position of the current piece depends on the board size
     * and the piece type/color generated by the factory
     */
    @Test
    public void spawnNewPieceTest() {
        MockBoard mockBoard = new MockBoard(10, 20);
        Game game = new Game(mockBoard, new MockTetrominoFactory('I', 1), GameState.RUNNING);
        Tetromino current = game.getCurrent();

        assertEquals(10 / 2 - 1, current.getX());
        assertEquals(20 - 1, current.getY());

        Game gameO = new Game(mockBoard, new MockTetrominoFactory('O', 3), GameState.RUNNING);
        Tetromino currentO = gameO.getCurrent();
        assertEquals('O', currentO.getShape());
        assertEquals(3, currentO.getColor());
        
        // Positioning for different board sizes
        MockBoard smallBoard = new MockBoard(8, 16);
        Game smallGame = new Game(smallBoard, new MockTetrominoFactory('I', 1), GameState.RUNNING);
        Tetromino smallCurrent = smallGame.getCurrent();
        assertEquals(8 / 2 - 1, smallCurrent.getX());
        assertEquals(16 - 1, smallCurrent.getY());
    }

    /**
     * test the automatic falling with tick()
     * each tick moves the current piece one row down
     * and when reaches the bottom or collides, lock down and spawns a new piece
     * the game state ramins RUNNING unless the new piece cant place --> gameover
     */
    @Test
    public void tickMovesPieceDown() {
        MockBoard mockBoard = new MockBoard(10, 20);
        Game game = new Game(mockBoard, new MockTetrominoFactory('I', 1), GameState.RUNNING);

        int initialY = game.getCurrent().getY();
        game.tick();
        assertEquals(initialY - 1, game.getCurrent().getY());

        // Drop collision at bottom
        while (game.getCurrent().getY() > 0) {
            game.tick();
        }
        int finalY = game.getCurrent().getY();
        assertEquals(0, finalY, "Piece should stop at bottom");

        // Piece -> locked & new one spawned
        Tetromino lockedPiece = game.getCurrent(); // after spawn
        assertNotNull(lockedPiece, "New piece should be spawned after locking");
        assertEquals(GameState.RUNNING, game.getGameState());

        // Game over
        Tetromino blocking = new Tetromino('I', 1);
        blocking.setPosition(mockBoard.getWidth() / 2 - 1, mockBoard.getHeight() - 1);
        mockBoard.placeTetromino(blocking);
    }

    /**
     * Test the horizontal movement, left and right of the current piece
     */
    @Test
    public void movementTest() {
        MockBoard mockBoard = new MockBoard(10, 20);
        Game game = new Game(mockBoard, new MockTetrominoFactory('I', 1), GameState.RUNNING);

        Tetromino current = game.getCurrent();
        int initialX = current.getX();

        // left decreases X
        game.moveLeft();
        assertEquals(initialX - 1, current.getX());

        // right increases X
        game.moveRight();
        assertEquals(initialX, current.getX());

        // collision: place a blocking piece at the left position
        Tetromino blocking = new Tetromino('I', 1);
        blocking.setPosition(initialX - 1, current.getY());
        mockBoard.placeTetromino(blocking);
    }

    /**
     * test the current piece rotation
     * verify that rotation changes the pieces orientation
     * and only works when no collision
     */
    @Test
    public void rotationTest() {
        MockBoard mockBoard = new MockBoard(10, 20);
        Game game = new Game(mockBoard, new MockTetrominoFactory('I', 1), GameState.RUNNING);

        Tetromino current = game.getCurrent();
        int initialRotation = current.getRotation();

        game.rotateCurrent();
        assertNotEquals(initialRotation, current.getRotation(), "Piece should rotate when no collision");
    }

}
